#### 二叉树

#### 堆

------

##### 定义

如果有一个关键码的集合K = {k0，k1， k2，…，kn-1}，把它的所有元素按完全二叉树的顺序存储方式存储在一个一维数组中，并满足：Ki <= K2*i+1* 且 *Ki<= K2*i+2 (Ki >= K2*i+1* 且 *Ki >= K2*i+2) i = 0，1，2…，则称为小堆(或大堆)。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。  

------

##### 性质

1. 堆的物理结构是一个数组

2. 堆的逻辑结构是完全二叉树

3. 大堆（树中的所有的父亲**大于等于**孩子），小堆（树中所有的父亲**小于等于**孩子）

4. 父子间的关系：
   $$
   leftchild = parent\times2 + 1;
   $$

   $$
   rightchild = parent\times2 + 2;
   $$

   右孩子一定是偶数，由于整型运算会省略小数，所以
   $$
   parent = (leftchild-1)\div2 =  (rightchild-1)\div2
   $$

------

##### 堆向下调整算法

时间复杂度$O(log_2N)$   

- 假设完全树的高度为h，结点个数为N，最后一层相对于满二叉数缺的结点为X，那么$2^h-1-X=N$

  所以$h=log_2N$,向下调整法最多调整h-1次，根据大O表示法就可以得到时间复杂度。

但是向下调整算法是在，左子树和右子树恰好是大堆或者小堆的情况下。

------

##### 建堆

> - 从最后一个非叶结点开始调整。所以要先找到这个结点，这个结点是最后一个结点的父节点
>
> - 我们已知下标之间的关系：**parent = (左孩子 - 1) / 2 = (右孩子 - 2) / 2**。
>   因为整型计算小数会被省略，**所以(左孩子-1) / 2 = (右孩子-1) / 2** 。
>   因为右孩子结点下标肯定是偶数，再减1就是奇数，然后除2肯定会省去小数位，这样跟直接用左孩子下标计算效果一样
>   因此找最后一个非叶结点只需要计算，最后一个结点下标-1再除2就行。n是结点个数，最后一个结点的下标是n-1，所以最后一个非叶结点的下标肯定为(n-1-1).
> - 然后把非叶结点挨个遍历，作为子树的父结点，使用向下调整法调整为最小堆就行。

建堆 - 时间复杂度$O(N)$

![image-20220727154326597](C:\Users\AKANG\AppData\Roaming\Typora\typora-user-images\image-20220727154326597.png)

------

##### 堆排序

1. 建堆。排升序建大堆，排降序建小堆。
   - 排升序时，选择排序的时间复杂度为$O(N^2)$。我们如果建立小堆的话，每次从头上选择最小的数，选完之后剩下的结点关系就乱了，又得重新建堆（建堆时间复杂度为O(N)），这样的话还不如直接使用选择排序
2. 排升序。
   - 先拿出第一层最大的结点跟最后一个结点（end）交换，然后不把最后一个结点看作堆里面的结点；
   - 使用向下调整算法调整堆；重复上面的步骤，直到最后一个数（end == 0）

时间复杂度$O(N\times logN)$

![image-20220727170750006](C:\Users\AKANG\AppData\Roaming\Typora\typora-user-images\image-20220727170750006.png)

